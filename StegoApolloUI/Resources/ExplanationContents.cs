namespace StegoApolloUI.Resources
{
    public static class ExplanationContents
    {
        // LSB
        public const string LsbTitle =
"LSB (Least Significant Bit) 演算法";
        public const string LsbContent =
@"LSB 是指在數位影像中，每個像素的每個顏色通道（紅、綠、藍）都是由 8 位元組成的數值（0-255）。這個演算法的核心理念是：修改這 8 位元中的最後一位（最不重要的位元），人眼幾乎察覺不到變化，但可以藉此隱藏資訊。例如，將 10101100 修改為 10101101，視覺上幾乎無差異。
程式實作與流程說明

- 讀取載入影像：先將原始影像載入記憶體
- 讀取要隱藏的訊息：將訊息轉換成二進位序列
- 將訊息嵌入影像：逐個像素修改最低位元，將二進位序列嵌入影像中
- 將修改後的影像儲存：將嵌入訊息的影像儲存為新檔案

嵌入訊息流程：

優缺點分析
優點：

實作非常簡單，容易理解與編程
容量大：每個像素可嵌入 3 位元資訊（RGB 各一位）
修改最小，視覺上幾乎無差異：只改變 0-1 之間的值

缺點：

非常脆弱：任何會改變最低位元的操作都會破壞隱藏的資訊
不耐任何形式的影像處理：如壓縮、模糊、亮度調整等
容易被檢測：統計分析最低位分佈即可發現異常";

        // QIM
        public const string QimTitle =
"QIM (Quantization Index Modulation) 演算法";
        public const string QimContent =
@"QIM 透過量化（Quantization）的方式隱藏資訊。簡單來說，就是將像素值分成規律的區間（例如間隔 Δ=4），然後根據要嵌入的位元值（0或1），將像素值調整到相應的區間中心點。
例如，設定 Δ=4：

如果要嵌入「0」，則將像素值調整為 4 的倍數（0, 4, 8, 12...）
如果要嵌入「1」，則將像素值調整為 4 的倍數 +2（2, 6, 10, 14...）

這樣設計的優勢是，即使像素值被輕微干擾（例如 ±1），提取時依然可以正確識別。
程式實作與流程說明

- 設定量化步長 Δ：通常選擇 4 或 8 等值
- 讀取載入影像：將原始影像載入記憶體
- 讀取要隱藏的訊息：將訊息轉換成二進位序列
- 將訊息嵌入影像：逐個像素根據要嵌入的位元值，調整像素值到相應的區間中心點
- 將修改後的影像儲存：將嵌入訊息的影像儲存為新檔案

視覺化說明
想像一個數線，標記 0, 1, 2, 3, 4, 5, 6, 7, 8...

嵌入「0」時，像素值會被調整到：0, 4, 8, 12... (4n)
嵌入「1」時，像素值會被調整到：2, 6, 10, 14... (4n+2)

這樣在提取時，只需要看像素值除以 Δ 後是偶數還是奇數即可。
優缺點分析
優點：

抗干擾能力強：即使像素值有小幅度變化，仍能正確提取資訊
直方圖呈現階梯狀，易於視覺檢查嵌入效果
相較於 LSB 更穩健，能承受輕微的影像處理操作

缺點：

容量較小：每個像素只能嵌入 1 位元資訊
視覺變化較 LSB 明顯：可能在平滑區域產生輕微可見的變化
量化步長與視覺質量、抗干擾能力成反比關係";

        // DCT-QIM
        public const string DctTitle =
"DCT-QIM (頻域量化調變) 演算法";
        public const string DctContent =
@"DCT-QIM 結合了頻域轉換與量化指數調變的優點。不同於前兩種在空間域直接處理像素值的方法，DCT-QIM 先將影像分割成 8×8 的區塊，對每個區塊進行離散餘弦變換（DCT），將資訊嵌入到變換後的頻域係數中。
基本流程：

影像分割為 8×8 區塊
每個區塊進行 DCT 轉換，得到 64 個頻域係數
選擇中頻係數進行 QIM 嵌入（避開低頻和高頻）
對修改後的區塊進行反 DCT 變換，還原到空間域

選擇中頻係數是因為：低頻係數包含影像主要視覺資訊，修改會造成明顯變化；高頻係數易受壓縮和處理影響。中頻係數既不太影響視覺質量，又相對穩定。

程式實作與流程說明
- 讀取載入影像：將原始影像載入記憶體
- 讀取要隱藏的訊息：將訊息轉換成二進位序列
- 將影像分割為 8×8 區塊
- 對每個區塊進行 DCT 轉換 (離散餘弦變換)，得到 64 個頻域係數
- 選擇中頻係數進行 QIM 嵌入：根據要嵌入的位元值，調整係數到相應的區間中心點
- 對修改後的區塊進行反 DCT 變換，還原到空間域
- 將修改後的影像儲存：將嵌入訊息的影像儲存為新檔案

視覺化說明
DCT 將空間域轉換到頻域，使每個 8×8 區塊被分解為不同頻率的成分：

左上角是低頻區，包含區塊的主要特徵
右下角是高頻區，包含細節和邊緣資訊
中間區域是中頻，修改它們對視覺影響較小

選擇係數位置 (u=4, v=5) 表示在 8×8 區塊的 DCT 係數矩陣中，選第 4 列第 5 行的係數進行修改。
優缺點分析
優點：

抗壓縮能力強：特別是對 JPEG 這類基於 DCT 的壓縮演算法
更隱蔽：修改在頻域中進行，空間域上的變化分散且不明顯
穩健性好：能抵抗多種影像處理操作，如輕微裁剪、旋轉等

缺點：

計算複雜度高：需要進行 DCT 和 IDCT 變換
容量受限：每個 8×8 區塊只能嵌入少量資訊
實作難度較高：需要理解 DCT 及其特性";

        public const string HSTitle = "Histogram Shifting (直方圖位移) 單通道藏密演算法";
        public const string HSContent = @"Histogram Shifting（直方圖位移）是一種基於統計特性的影像隱寫技術，主要運用像素數值分布的『峰值點（Peak Point, P）』與『零點（Zero Point, Z）』，在極小改動下達成資訊嵌入。此方法相較於傳統 LSB 更能保證資訊只分布於特定像素群，有較佳的隱蔽性與還原性。

核心原理：
- 選取一條通道（如 R 紅色），統計其所有像素的數值分布（直方圖）。
- 找出數量最多的像素數值（Peak Point, P）作為主要嵌入位置，以及最接近且數量為 0 的數值（Zero Point, Z）作為可位移目的地。
- 將 P、Z 之間的像素依規則『往 Z 方向位移一格』，騰出空間後，使用 P 點像素藏入訊息位元（0: P，1: P+1）。
- 嵌入訊息長度（4 bytes）、Peak/Zero 值等 Metadata 一併記錄於影像檔內。

嵌入與萃取步驟：
1. 計算影像的目標通道直方圖，尋找 Peak（P）與 Zero（Z）點，**P 與 Z 僅允許在 2~253 及 1~254 範圍內，避開邊界以防止位移溢位**。
2. 將 P、Z 之間的像素做一次位移，保留訊息嵌入空間。
3. 將欲嵌入訊息（含長度）依序轉為位元，寫入所有 P 點像素（P 嵌入 0，P+1 嵌入 1）。
4. 輸出含 metadata 的藏密影像。

資訊萃取時，根據 metadata 還原 Peak/Zero 點與藏入順序，依序讀出訊息長度與內容。

優缺點分析
優點：
- 僅改動分布最密集的像素，整體影像失真極小。
- 具自我還原性，可於萃取後回復原始影像。
- 嵌入點明確，有一定抗分析能力。

缺點：
- 嵌入容量受限於 peak 點數量，圖片分布不佳時容量會大幅下降。
- P/Z 需避開 0,1,254,255 等邊界，否則易溢位或導致訊息無法正確還原。
- 仍對某些影像處理（壓縮、顏色調整）較為敏感。

**特別說明：**
- 本演算法已加入 P、Z 區間檢查，若 histogram 無法找到安全的 Peak/Zero，系統將提示不適合嵌入。
- 嵌入容量若不足，也會自動拒絕並顯示錯誤訊息，確保訊息完整與可靠還原。
";
    }
}
